"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdateruby_openai"]("main",{

/***/ "./node_modules/unplugin/dist/webpack/loaders/transform.js?unpluginName=unplugin-vue-components!./node_modules/unplugin/dist/webpack/loaders/transform.js?unpluginName=unplugin-auto-import!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./frontend_app/pages/Dashboard.vue?vue&type=script&lang=js"
/*!*********************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/unplugin/dist/webpack/loaders/transform.js?unpluginName=unplugin-vue-components!./node_modules/unplugin/dist/webpack/loaders/transform.js?unpluginName=unplugin-auto-import!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./frontend_app/pages/Dashboard.vue?vue&type=script&lang=js ***!
  \*********************************************************************************************************************************************************************************************************************************************************************************************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _constant_Constants_vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constant/Constants.vue */ \"./frontend_app/constant/Constants.vue\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! axios */ \"./node_modules/axios/lib/axios.js\");\n/* harmony import */ var marked__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! marked */ \"./node_modules/marked/lib/marked.esm.js\");\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.runtime.esm-bundler.js\");\n/* harmony import */ var vue_router__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vue-router */ \"./node_modules/vue-router/dist/vue-router.mjs\");\n/* harmony import */ var element_plus__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! element-plus */ \"./node_modules/element-plus/es/components/notification/index.mjs\");\n/* harmony import */ var vuex__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! vuex */ \"./node_modules/vuex/dist/vuex.esm-bundler.js\");\n/* harmony import */ var element_plus_es__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! element-plus/es */ \"./node_modules/element-plus/es/components/message-box/index.mjs\");\n/* harmony import */ var element_plus_es_components_base_style_css__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! element-plus/es/components/base/style/css */ \"./node_modules/element-plus/es/components/base/style/css.mjs\");\n/* harmony import */ var element_plus_es_components_message_box_style_css__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! element-plus/es/components/message-box/style/css */ \"./node_modules/element-plus/es/components/message-box/style/css.mjs\");\n/* unplugin-vue-components disabled */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\r\n  setup() {\r\n\r\n    const drawer = (0,vue__WEBPACK_IMPORTED_MODULE_3__.ref)(false)\r\n    const hasFinishTask = (0,vue__WEBPACK_IMPORTED_MODULE_3__.ref)(false);\r\n    const ipAddress = (0,vue__WEBPACK_IMPORTED_MODULE_3__.ref)('');\r\n    const messages = (0,vue__WEBPACK_IMPORTED_MODULE_3__.ref)([]);\r\n    const textAreaWordCount = (0,vue__WEBPACK_IMPORTED_MODULE_3__.ref)(0);\r\n    const scenarioText = (0,vue__WEBPACK_IMPORTED_MODULE_3__.ref)('');\r\n    const minWords = _constant_Constants_vue__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ACCEPTABLE_MIN_WORDS;\r\n    const maxWords = _constant_Constants_vue__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ACCEPTABLE_MAX_WORDS;\r\n    const userInput = (0,vue__WEBPACK_IMPORTED_MODULE_3__.ref)('');\r\n    const textArea = (0,vue__WEBPACK_IMPORTED_MODULE_3__.ref)('');\r\n    const textareaRef = (0,vue__WEBPACK_IMPORTED_MODULE_3__.ref)(null); // Add this line to define a ref for the textarea\r\n    const highlightedText=(0,vue__WEBPACK_IMPORTED_MODULE_3__.ref)('');\r\n    const route = (0,vue_router__WEBPACK_IMPORTED_MODULE_4__.useRoute)();\r\n    const router = (0,vue_router__WEBPACK_IMPORTED_MODULE_4__.useRouter)();\r\n    const user_id = (0,vue__WEBPACK_IMPORTED_MODULE_3__.ref)('anonymous');\r\n    let promptStartTime=0\r\n    let promptEndTime=0\r\n    const wordEditingCount=(0,vue__WEBPACK_IMPORTED_MODULE_3__.ref)(0)\r\n    \r\n    const wordDeletingCount=(0,vue__WEBPACK_IMPORTED_MODULE_3__.ref)(0)\r\n    const characterRevisionCount=(0,vue__WEBPACK_IMPORTED_MODULE_3__.ref)(0)\r\n    let previousCharacterCount=0\r\n    let timeId\r\n\r\n    // Timer\r\n    const TIME_GAP =_constant_Constants_vue__WEBPACK_IMPORTED_MODULE_0__[\"default\"].TIME_GAP;\r\n    const MISSION_TIME = _constant_Constants_vue__WEBPACK_IMPORTED_MODULE_0__[\"default\"].MISSION_TIME;\r\n    const MISSION_EXPIRE_TIME = _constant_Constants_vue__WEBPACK_IMPORTED_MODULE_0__[\"default\"].MISSION_EXPIRE_TIME;\r\n    const timeSeconds = (0,vue__WEBPACK_IMPORTED_MODULE_3__.ref)(\"10m:00s\");\r\n    \r\n\r\n    const missionTimeStamp = (0,vue__WEBPACK_IMPORTED_MODULE_3__.ref)(new Date().getTime());\r\n\r\n\r\n    // streaming variables\r\n    const messageSending = (0,vue__WEBPACK_IMPORTED_MODULE_3__.ref)(false);\r\n\r\n    // shared store variables\r\n\r\n    const store = (0,vuex__WEBPACK_IMPORTED_MODULE_6__.useStore)()\r\n    const updateSharedVariable = (obj) => {\r\n      store.commit('updateSharedVariable', obj)\r\n    }\r\n\r\n\r\n    const currentTemp=(0,vue__WEBPACK_IMPORTED_MODULE_3__.ref)(_constant_Constants_vue__WEBPACK_IMPORTED_MODULE_0__[\"default\"].DEFAULTS_TEMP)\r\n    const MAX_TEMP=_constant_Constants_vue__WEBPACK_IMPORTED_MODULE_0__[\"default\"].MAX_TEMP\r\n    const MIN_TEMP=_constant_Constants_vue__WEBPACK_IMPORTED_MODULE_0__[\"default\"].MIN_TEMP\r\n    // try to fix the mounted issue\r\n    let focus_leave=new Date().getTime();\r\n\r\n    //  test for tour\r\n    const chatInputRef = (0,vue__WEBPACK_IMPORTED_MODULE_3__.ref)(null)\r\n    const scenarioRef = (0,vue__WEBPACK_IMPORTED_MODULE_3__.ref)(null)\r\n    const noteRef = (0,vue__WEBPACK_IMPORTED_MODULE_3__.ref)(null)\r\n    const chatBotRef = (0,vue__WEBPACK_IMPORTED_MODULE_3__.ref)(null)\r\n    const submitTaskRef = (0,vue__WEBPACK_IMPORTED_MODULE_3__.ref)(null)\r\n    const infoRef = (0,vue__WEBPACK_IMPORTED_MODULE_3__.ref)(null)\r\n    const scrollContainer = (0,vue__WEBPACK_IMPORTED_MODULE_3__.ref)(null);\r\n\r\n    const mobileDrawer = (0,vue__WEBPACK_IMPORTED_MODULE_3__.ref)(window.innerWidth<992?true:false)\r\n    const open = (0,vue__WEBPACK_IMPORTED_MODULE_3__.ref)(true)\r\n    const attendTour=(0,vue__WEBPACK_IMPORTED_MODULE_3__.ref)(false)\r\n    let localData ={}\r\n\r\n    // input row\r\n    const textAreaRowRef = (0,vue__WEBPACK_IMPORTED_MODULE_3__.ref)(8);\r\n\r\n    // watchEffect(async () => {\r\n    //   // ...\r\n    //   console.log('Change Url:');\r\n    //   user_id.value = route.query[Constants.URL_USER_PARAMS] || 'anonymous';\r\n    //   if(user_id.value === 'anonymous'){\r\n    //     router.push({ path: '/missing' })\r\n    //   }\r\n    //   updateSharedVariable({'user_id': user_id.value});\r\n    //   localData['user_id'] = user_id.value\r\n    //   if (!localStorage.getItem(user_id.value)) {\r\n    //     localStorage.setItem(user_id.value, JSON.stringify(localData));\r\n    //   } else {\r\n    //     const data = await localStorage.getItem(user_id.value);\r\n    //     localData = JSON.parse(data);\r\n    //     textArea.value = localData['storage_notes']||'';\r\n    //     wordEditingCount = localData['word_editing_count']||0;\r\n    //     wordDeletingCount = localData['word_deleted_count']||0;\r\n    //     characterRevisionCount = localData['character_revision_count']||0;\r\n    //     if(textArea.value){\r\n    //       previousCharacterCount = textArea.value.length;\r\n    //       textAreaWordCount.value = textArea.value.trim().split(/\\s+|\\n+/).length;\r\n    //     }\r\n    //     if(localData['tour']===false){\r\n    //       open.value = localData['tour'];\r\n    //       timeId = setInterval(setTimer, TIME_GAP*1000);\r\n    //     }\r\n    //   }\r\n    // });\r\n\r\n    const readStorage=() => {\r\n      user_id.value = route.query[_constant_Constants_vue__WEBPACK_IMPORTED_MODULE_0__[\"default\"].URL_USER_PARAMS] || 'anonymous';\r\n      // Commented out redirect to allow local testing without PROLIFIC_PID\r\n      // if (user_id.value === 'anonymous') {\r\n      //   router.push({ path: '/missing' });\r\n      // }\r\n      updateSharedVariable({ 'user_id': user_id.value });\r\n      localData['user_id'] = user_id.value;\r\n\r\n      const raw = localStorage.getItem(user_id.value);\r\n      if (!raw) {\r\n        // initialize storage for this user\r\n        localStorage.setItem(user_id.value, JSON.stringify(localData));\r\n        return;\r\n      }\r\n\r\n      let parsed = {};\r\n      try {\r\n        parsed = JSON.parse(raw) || {};\r\n      } catch {\r\n        // reset corrupted storage\r\n        localStorage.setItem(user_id.value, JSON.stringify(localData));\r\n        parsed = {};\r\n      }\r\n\r\n      localData = parsed;\r\n\r\n      textArea.value = localData['storage_notes'] || '';\r\n      wordEditingCount.value = localData['wordEditingCount'] || 0;\r\n      wordDeletingCount.value = localData['wordDeletingCount'] || 0;\r\n      characterRevisionCount.value = localData['characterRevisionCount'] || 0;\r\n\r\n      if (textArea.value !== undefined && textArea.value !== null) {\r\n        previousCharacterCount = textArea.value.length;\r\n        const trimmed = textArea.value.trim();\r\n        textAreaWordCount.value = trimmed ? trimmed.split(/\\s+|\\n+/).length : 0;\r\n      }\r\n\r\n      missionTimeStamp.value = localData['missionTimeStamp'] || new Date().getTime();\r\n\r\n      if (localData['tour'] === false) {\r\n        open.value = localData['tour'];\r\n        attendTour.value = !localData['tour'];\r\n        timeId = setInterval(setTimer, TIME_GAP * 1000);\r\n      }\r\n    };\r\n\r\n    (0,vue__WEBPACK_IMPORTED_MODULE_3__.watch)(messages, () => {\r\n      // Wait for the next DOM update to scroll\r\n      (0,vue__WEBPACK_IMPORTED_MODULE_3__.nextTick)(() => {\r\n        scrollToBottom();\r\n      });\r\n    }, { deep: true });\r\n\r\n\r\n    // console.log('Query Parameters:', route.query);\r\n    (0,vue__WEBPACK_IMPORTED_MODULE_3__.onMounted)(async() => {\r\n      focus_leave=new Date().getTime();\r\n      document.addEventListener('keydown', handleHighlight);\r\n      await readStorage();\r\n      await checkFinishTask(); \r\n      await initialMessages();\r\n      await getTask();\r\n      await getIPFromAmazon();\r\n      await updateIp();\r\n      sendBehavior({\r\n            id: Date.now(),\r\n            content: 'User is open the page on' + Date.now().toString(),\r\n            type: 'Initial',\r\n            target_object: 'Page',\r\n            log_time: new Date().toISOString(),\r\n       }); \r\n      document.addEventListener('visibilitychange',handleVisibilityChange);  \r\n    })\r\n\r\n    // Don't forget to clean up the event listener on component unmount\r\n    ;(0,vue__WEBPACK_IMPORTED_MODULE_3__.onUnmounted)(() => {\r\n      document.removeEventListener('visibilitychange',handleVisibilityChange);\r\n      document.removeEventListener('keydown', handleHighlight);\r\n      // remove the interval in timer\r\n      clearInterval(timeId);\r\n    });\r\n\r\n\r\n    // Tour \r\n    const tourFinished = () => {\r\n      console.log('Tour Finished');\r\n      if(localData['tour']===undefined || localData['tour']===true){\r\n          missionTimeStamp.value=new Date().getTime()\r\n          localData['missionTimeStamp']=missionTimeStamp.value;\r\n          timeId = setInterval(setTimer, TIME_GAP*1000); \r\n        }\r\n      localData['tour']=false;\r\n      attendTour.value=true;\r\n      localStorage.setItem(user_id.value, JSON.stringify(localData));\r\n    };\r\n\r\n    // Timer\r\n    function setTimer() {\r\n    \r\n      // if(missionTimeStamp.value===0){\r\n      //   missionTimeStamp.value=new Date().getTime()\r\n      // };\r\n      let currentTime = new Date().getTime();\r\n      // console.log('Current Time:',missionTimeStamp,\"  : \", currentTime);\r\n\r\n      let missionTimeLeft=MISSION_TIME-Math.floor((currentTime-missionTimeStamp.value)/1000);\r\n      if( missionTimeLeft <= 0 && missionTimeLeft >= -TIME_GAP){\r\n        (0,element_plus__WEBPACK_IMPORTED_MODULE_5__.ElNotification)({\r\n          title: 'Reminder',\r\n          message: `You have spent ${Math.floor(MISSION_TIME/60)} minutes on the task.`,\r\n          type: 'info',\r\n        })\r\n        timeSeconds.value = `<span style=\"color: rgb(190, 79, 79);\"> Please submit as soon as possible!</span>`;\r\n      }\r\n      else if(missionTimeLeft >0){\r\n        timeSeconds.value = \" \" + pad(Math.floor(missionTimeLeft / 60)) +\"m:\"+ pad(missionTimeLeft % 60)+\"s\";\r\n      }\r\n    }\r\n\r\n    function pad(val) {\r\n      let valString = val + \"\";\r\n      if (valString.length < 2) {\r\n        return \"0\" + valString;\r\n      } else {\r\n        return valString;\r\n      }\r\n    }\r\n\r\n\r\n    // Chat to bottom\r\n    async function scrollToBottom() {\r\n      try{\r\n        if (scrollContainer.value) {\r\n          scrollContainer.value.setScrollTop(1e16);\r\n        }\r\n      }catch(error){\r\n        console.error('Failed to scroll to bottom:', error);\r\n      }\r\n      // scrollContainer.value.setScrollTop(1e16);\r\n    }\r\n\r\n    // Error Prevention\r\n    // TODO: check the error handling\r\n    const checkTaskFinish= () => {\r\n      if(!hasFinishTask.value){\r\n        if(textAreaWordCount.value>=minWords && textAreaWordCount.value<=maxWords){\r\n          return new Promise((resolve) => {\r\n            setTimeout(() => {\r\n              (0,element_plus__WEBPACK_IMPORTED_MODULE_5__.ElNotification)({\r\n                title: 'Notice',\r\n                message: 'You can submit the task now.',\r\n                type: 'success',\r\n              })\r\n              return resolve(true)\r\n            }, 100)\r\n          })\r\n        }else{\r\n            return new Promise((_, reject) => {\r\n              setTimeout(() => {\r\n                (0,element_plus__WEBPACK_IMPORTED_MODULE_5__.ElNotification)({\r\n                    title: 'Warning',\r\n                    message: `Task not finished. Please write between ${minWords} and ${maxWords}  words.`,\r\n                    type: 'warning',\r\n                })\r\n                return reject(new Error('Error'))\r\n              }, 100)\r\n            })\r\n        }\r\n      }else{\r\n        return true;\r\n      }\r\n\r\n    }\r\n    \r\n\r\n    // API related\r\n    const initialMessages = async ()=>{\r\n\r\n      try {\r\n        let api_url = \"/messages\";\r\n        if(user_id.value !== 'anonymous'){\r\n          api_url = `/messages?user_id=${user_id.value}`;\r\n        } \r\n        const { data } = await axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(api_url);\r\n        messages.value = data.map( (chat)=>{\r\n          return {\r\n            id: chat.created_at,\r\n            text: (0,marked__WEBPACK_IMPORTED_MODULE_2__.marked)(chat.response),\r\n            sender: chat.role,\r\n          }\r\n        \r\n        }); // Assuming the data is an array of messages\r\n        (0,vue__WEBPACK_IMPORTED_MODULE_3__.nextTick)(() => {\r\n          scrollToBottom();\r\n        });\r\n      } catch (error) {\r\n        console.error(\"Failed to fetch initial messages:\", error);\r\n        sendError({error_message:\"Failed to fetch initial messages:\"+ error});\r\n      }\r\n    \r\n    }\r\n\r\n    const sendMessage = async() => {\r\n      if (userInput.value.trim()) {\r\n        // messages.value.push({ id: Date.now(), text: userInput.value, sender: 'user' });\r\n        // Here you'd typically send the message to your backend for processing\r\n        createMessage((0,marked__WEBPACK_IMPORTED_MODULE_2__.marked)(userInput.value),'user');\r\n\r\n        // API for none streaming version\r\n        // getResponse(userInput.value);\r\n        // API for streaming version\r\n        await streamingResponse();\r\n\r\n        userInput.value = ''; // Clear input after sending\r\n        // console.log('User Prompt Time:', (promptEndTime-promptStartTime)/1000);\r\n        promptStartTime=0;\r\n        promptEndTime=0;\r\n      }\r\n      else{\r\n        (0,element_plus__WEBPACK_IMPORTED_MODULE_5__.ElNotification)({\r\n          title: 'Notice',\r\n          message: \"The message can't be empty!\",\r\n          type: 'warning',\r\n        })\r\n      }\r\n    };\r\n\r\n\r\n  const sendBehavior = async (behavior) => {\r\n    if (behavior) {\r\n      let api_url = \"/behavior\";\r\n      if (user_id.value !== 'anonymous') {\r\n        api_url = `/behavior?user_id=${user_id.value}`;\r\n      }\r\n      try {\r\n        const { data } = await axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].post(api_url, behavior);\r\n        // console.log('Response Behavior', data);\r\n      } catch (error) {\r\n        console.error('Failed to send behavior:', error);\r\n        sendError({error_message:\"Failed to send behavior:\"+ error});\r\n        \r\n        // Handle specific error scenarios here if needed\r\n      }\r\n    }\r\n  }\r\n  const sendError = async (error) => {\r\n    if (error) {\r\n      let api_url = \"/error-log\";\r\n      if (user_id.value !== 'anonymous') {\r\n        api_url = `/error-log?user_id=${user_id.value}`;\r\n      }\r\n      try {\r\n        const { data } = await axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].post(api_url, error);\r\n        // console.log('Response Behavior', data);\r\n      } catch (err) {\r\n        console.error('Failed to send error:', err);\r\n        // Handle specific error scenarios here if needed\r\n      }\r\n    }\r\n  }\r\n\r\n  const checkFinishTask = async () => {\r\n    try {\r\n      let api_url = \"/task\";\r\n      if(user_id.value !== 'anonymous'){\r\n        api_url = `/task?user_id=${user_id.value}`;\r\n      }\r\n      const { data } = await axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(api_url);\r\n      if(data.final_submission){\r\n        router.push({ path: '/submitted' })\r\n      }\r\n    }\r\n    catch (error) {\r\n      sendError({error_message:\"Failed to fetch task:\"+ error});\r\n      console.error('Failed to fetch task:', error);\r\n    }\r\n  \r\n  }\r\n\r\n  const getTask = async () => {\r\n    if(!localData['task']||localData['task'].expire_time < new Date().getTime()){\r\n      //if no task in local storage or task is expired\r\n      try {\r\n        let api_url = \"/random-task\";\r\n        if(user_id.value !== 'anonymous'){\r\n          api_url = `/random-task?user_id=${user_id.value}`;\r\n        } \r\n        const { data } = await axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(api_url);\r\n        console.log('Task:', data);\r\n        // delete data['final_submission']\r\n        // delete data['chat_id']\r\n        // message_id\r\n        // receipt_handle\r\n        data.expire_time = new Date().getTime() + MISSION_EXPIRE_TIME*1000;\r\n        localData['task']=data;\r\n        localStorage.setItem(user_id.value, JSON.stringify(localData))\r\n      } catch (error) {\r\n        console.error('Failed to fetch task:', error);\r\n        sendError({error_message:\"Failed to fetch task:\"+ error});\r\n        // Use a default task to prevent infinite reload\r\n        localData['task'] = {\r\n          task_name: 'CREATIVE',\r\n          message_id: 'default',\r\n          receipt_handle: 'default',\r\n          expire_time: new Date().getTime() + MISSION_EXPIRE_TIME*1000\r\n        };\r\n        localStorage.setItem(user_id.value, JSON.stringify(localData));\r\n      }\r\n    }\r\n    if(localData['task'] && localData['task'].task_name==='CREATIVE'){\r\n        scenarioText.value = _constant_Constants_vue__WEBPACK_IMPORTED_MODULE_0__[\"default\"].CREATIVE;\r\n      }\r\n    else{\r\n      scenarioText.value = _constant_Constants_vue__WEBPACK_IMPORTED_MODULE_0__[\"default\"].PRACTICAL;\r\n    }\r\n\r\n  }\r\n\r\n  const onSubmitTask = async () => {\r\n    try {\r\n      let api_url = \"/submit-task\";\r\n      if(user_id.value !== 'anonymous'){\r\n        api_url = `/submit-task?user_id=${user_id.value}`\r\n        ;\r\n      } \r\n      const missionTime=Math.floor((new Date().getTime()-missionTimeStamp.value)/1000);\r\n      const { data } = await axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].post(api_url,\r\n        {task_description: textArea.value , \r\n          message_id: localData['task'].message_id,\r\n          receipt_handle: localData['task'].receipt_handle,\r\n          task_name:localData['task'].task_name,\r\n          task_finished_time:missionTime,\r\n          word_editing_count: wordEditingCount.value,\r\n          word_deleted_count: wordDeletingCount.value,\r\n          character_revision_count: characterRevisionCount.value});\r\n      (0,element_plus__WEBPACK_IMPORTED_MODULE_5__.ElNotification)({\r\n          title: 'Finish',\r\n          message: \"You have Successfully Submit the task!\",\r\n          type: 'success',\r\n      })\r\n      updateSharedVariable({submitted: true});\r\n      router.push({ path: '/submitted' })\r\n    } catch (error) {\r\n      console.error('Failed to Submit task:', error);\r\n      sendError({error_message:\"Failed to Submit task:\"+ error});\r\n    }\r\n  }\r\n\r\n  const updateIp = async () => {\r\n    try {\r\n      let api_url = \"/update_ip\";\r\n      if(user_id.value !== 'anonymous'){\r\n        api_url = `/update_ip?user_id=${user_id.value}`\r\n        ;\r\n      } \r\n      const { data } = await axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].post(api_url,{ip_address: ipAddress.value});\r\n      // console.log('IP value:',ipAddress.value);\r\n      // console.log('Update IP:', data);\r\n    } catch (error) {\r\n      console.error('Failed to update IP:', error);\r\n      sendError({error_message:\"Failed to update IP:\"+ error});\r\n    }\r\n\r\n  }\r\n\r\n  let controller = null; \r\n  const streamingResponse = async () => {\r\n    messageSending.value = true;\r\n    let insufficient=false;\r\n    let save_message = '';\r\n    let streaming_message = '';\r\n    let api_url = \"/openAI-streaming\";\r\n    if(user_id.value !== 'anonymous'){\r\n      api_url = `/openAI-streaming?user_id=${user_id.value}`\r\n      ;\r\n    } \r\n    controller = new AbortController();\r\n    const signal = controller.signal;\r\n    try {\r\n      const receivedMessage ={\r\n        id: Date.now(),\r\n        text: '',\r\n        sender: 'assistant',\r\n      };\r\n      messages.value.push(receivedMessage);\r\n      if(promptEndTime===0){\r\n        promptEndTime=new Date().getTime();\r\n      }\r\n      \r\n      const response = await fetch(api_url,\r\n      {\r\n        method: \"POST\",\r\n        headers: {\r\n        \"Content-Type\": \"application/json\",\r\n        },\r\n        body: JSON.stringify({\r\n          message_content: userInput.value,\r\n          system_temp: currentTemp.value,\r\n          role: \"user\",\r\n          prompt_time: (promptEndTime-promptStartTime)/1000,\r\n        }),\r\n        signal,\r\n      });\r\n      promptStartTime=0;\r\n      promptEndTime=0;\r\n      userInput.value = '';\r\n      // disabled the sender button\r\n      const reader = response.body.getReader();\r\n      const decoder = new TextDecoder(\"utf-8\",{ stream: true });\r\n\r\n      while(true){\r\n        const {done, value} = await reader.read();\r\n        if(done){\r\n          break;\r\n        }\r\n        const chunk = decoder.decode(value);\r\n\r\n        const lines = chunk.split(\"\\n\");\r\n        if(insufficient){\r\n          lines[0] = save_message + lines[0];\r\n          insufficient=false;\r\n        }\r\n        console.log('Streaming Lines:', lines);\r\n        // const parsedLines = lines.filter((line) => line.trim() !== ''  && !line.includes(\"[DONE]\"))\r\n        //                         .map((line)=>line.replace(/^data: /, \"\").trim())\r\n        //                         .map((line) => JSON.parse(line));\r\n\r\n        const parsedLines = lines\r\n              .filter((line) => line.trim() !== \"\" && !line.includes(\"\\[DONE\\]\"))\r\n              .map((line) => line.replace(/^data: /, \"\").trim())\r\n              .map((line) => {\r\n                try {\r\n                  return JSON.parse(line);\r\n                } catch (error) {\r\n                  console.error(\"Failed to parse JSON line:\", line);\r\n                  // sendError({error_message:\"Failed to parse JSON line:\"+ line});\r\n                  insufficient=true;\r\n                  save_message = line;\r\n\r\n                  console.error(error);\r\n                  return null; // or handle the error in a different way\r\n                }\r\n              })\r\n              .filter((parsedLine) => parsedLine !== null); // Filter out null values caused by parsing errors\r\n\r\n        // console.log('Streaming Response:', parsedLines);\r\n        for ( const parsedLine of parsedLines){\r\n          const {choices} = parsedLine;\r\n          const { delta } = choices[0];\r\n          const { content } = delta;\r\n          if(content){\r\n            streaming_message += content;\r\n            messages.value[messages.value.length - 1][\"text\"] = (0,marked__WEBPACK_IMPORTED_MODULE_2__.marked)(streaming_message);\r\n          }         \r\n          // console.log('Store to messages:', messages.value[messages.value.length - 1]);\r\n          // console.log('Streaming Response:', streaming_message);\r\n          // createMessage(marked(parsedLine.response), \"assistant\");\r\n        }\r\n\r\n      }\r\n\r\n      // console.log('Streaming Response:', data);\r\n    } catch (error) {\r\n      if(signal.aborted){\r\n        console.error('Request Aborted:', error);\r\n      }else{\r\n        console.error('Failed to Streaming:', error);\r\n        sendError({error_message:\"Failed to Streaming:\"+ error});\r\n      }\r\n    }finally{\r\n      controller = null;\r\n      messageSending.value = false;\r\n      // send API to backend\r\n      await storeMessage(streaming_message,'assistant');\r\n    }\r\n  }\r\n\r\n  const storeMessage = async (message,role) => {\r\n    try{\r\n      const postData = {\r\n        message_content: message,\r\n        system_temp: currentTemp.value,\r\n        role: role,\r\n      };\r\n      console.log('Post Data:', postData);\r\n        let api_url = \"/message\";\r\n        if(user_id.value !== 'anonymous'){\r\n          api_url = `/message?user_id=${user_id.value}`;\r\n        } \r\n      const { data } = await axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].post(api_url, postData);\r\n      console.log('Store Message:', data);\r\n\r\n    }catch(error){\r\n      console.error('Failed to store message:', error);\r\n      sendError({error_message:\"Failed to store message:\"+ error});\r\n    }\r\n  }\r\n\r\n    \r\n\r\n    //Create a message\r\n    function createMessage(message,identity) {\r\n      let id = 0;\r\n      if (messages.value[messages.value.length - 1]) {\r\n        id = messages.value[messages.value.length - 1].id + 1;\r\n      }\r\n      messages.value.push({\r\n        id: Date.now(),\r\n        text: message,\r\n        sender: identity || \"user\",\r\n        temp: currentTemp.value,\r\n      });\r\n    }\r\n    // Get response from the backend\r\n\r\n    async function getResponse(message) {\r\n      const postData = {\r\n        message_content: message,\r\n        system_temp: currentTemp.value,\r\n        role: \"user\",\r\n      };\r\n        let api_url = \"/openai\";\r\n        if(user_id.value !== 'anonymous'){\r\n          api_url = `/openai?user_id=${user_id.value}`;\r\n        } \r\n      const { data } = await axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].post(api_url, postData);\r\n      // console.log(data);\r\n      createMessage((0,marked__WEBPACK_IMPORTED_MODULE_2__.marked)(data.response), \"assistant\");\r\n    }\r\n\r\n\r\n    // Event listeners\r\n    let focusTimeStart = 0;\r\n    let focusTimeEnd = 0;\r\n    const handleInput = (e, value) => {\r\n      let inputValue;\r\n      if (e && e.target) {\r\n        inputValue = e.target.value;\r\n      } else {\r\n        inputValue = value;\r\n      }\r\n      if (inputValue !== undefined) {\r\n        if(previousCharacterCount ===inputValue.length-1 || previousCharacterCount ===inputValue.length+1){\r\n          characterRevisionCount.value+=1;\r\n          localData['characterRevisionCount']=characterRevisionCount.value;\r\n        }\r\n        previousCharacterCount = textArea.value.length;\r\n        textArea.value = inputValue;\r\n        localData['storage_notes']=inputValue\r\n        \r\n        // localStorage.setItem('storage_notes', inputValue);\r\n        // console.log('Input Value:', inputValue, inputValue.split(/\\s+|\\n+/).length);\r\n        const words = inputValue.trim().split(/\\s+|\\n+/);\r\n        let previousWordCount = textAreaWordCount.value;\r\n        // If the trimmed inputValue is empty, set word count to 0, else to the length of the words array\r\n        textAreaWordCount.value = inputValue.trim() ? words.length : 0;\r\n        if (previousWordCount !== textAreaWordCount.value) {\r\n          // console.log('Word Add/Remove:', inputValue);\r\n          sendBehavior({\r\n            id: Date.now(),\r\n            content: inputValue,\r\n            type: 'Word Add/Remove',\r\n            target_object: 'NoteArea',\r\n            log_time: new Date().toISOString(),\r\n          })\r\n          if(textAreaWordCount.value<minWords || textAreaWordCount.value>maxWords){\r\n            hasFinishTask.value = false;\r\n          }\r\n        }\r\n        if(previousWordCount === textAreaWordCount.value-1){    \r\n          wordEditingCount.value+=1;\r\n          localData['wordEditingCount']=wordEditingCount.value;\r\n        }else if(previousWordCount > textAreaWordCount.value){\r\n          wordDeletingCount.value+=previousWordCount - textAreaWordCount.value;\r\n          localData['wordDeletingCount']=wordDeletingCount.value;\r\n      }\r\n      localStorage.setItem(user_id.value, JSON.stringify(localData));\r\n    };\r\n  };\r\n    const handlePromptInput = (e, value) => {\r\n      let promptInputValue;\r\n      if (e && e.target) {\r\n        promptInputValue = e.target.value;\r\n      } else {\r\n        promptInputValue = value;\r\n      }\r\n      if(promptInputValue!==undefined){     \r\n        if(promptStartTime===0){\r\n          promptStartTime=new Date().getTime();\r\n        }\r\n        else{\r\n          promptEndTime=new Date().getTime();\r\n        }\r\n      }\r\n    };\r\n    // unused function\r\n    const clearTextArea = () => {\r\n       element_plus_es__WEBPACK_IMPORTED_MODULE_7__.ElMessageBox.confirm('Are you sure to delete all of the text?')\r\n        .then(() => {\r\n          textArea.value = '';\r\n          textAreaWordCount.value = 0; // Explicitly set word count to 0 here\r\n          localData['storage_notes']=''\r\n          localStorage.setItem(user_id.value, JSON.stringify(localData));\r\n\r\n          handleInput(null, ''); \r\n          sendBehavior({\r\n            id: Date.now(),\r\n            content: 'User Cleared TextBox',\r\n            type: 'Clear',\r\n            target_object: 'NoteArea',\r\n            log_time: new Date().toISOString(),\r\n          })  \r\n          highlightedText.value='User Cleared TextBox:'\r\n          done()\r\n        })\r\n        .catch((err) => {\r\n        })\r\n\r\n     \r\n    };\r\n    // unused function\r\n    const handleCopiedButton = async(e) => {\r\n      // console.log(e.target);\r\n      let targetElement = e.target;\r\n      if(!targetElement.id){\r\n        targetElement = e.target.parentElement;\r\n      }\r\n      // console.log(targetElement.id);\r\n      const messageId = targetElement.id.split('_')[1]; // Extract the message ID from the parent element's ID\r\n      const aiResponseElement = document.getElementById(`ai_feedback_${messageId}`);\r\n      // console.log('Response element:', aiResponseElement);\r\n      const copiedText = aiResponseElement.textContent;\r\n      sendBehavior({\r\n        id: Date.now(),\r\n        content: copiedText,\r\n        type: 'Copy',\r\n        target_object: aiResponseElement.name||aiResponseElement.id||aiResponseElement.nodeName,\r\n        log_time: new Date().toISOString(),\r\n      })\r\n\r\n      const tempInput = document.createElement('textarea');\r\n      tempInput.value = copiedText;\r\n      document.body.appendChild(tempInput);\r\n      tempInput.select();\r\n      document.execCommand('copy');\r\n      document.body.removeChild(tempInput);\r\n\r\n      highlightedText.value='Copied from Button: '+copiedText\r\n    };\r\n\r\n\r\n    const handleCopy = (e) => {\r\n      // console.log(e.clipboardData.getData('text/plain'));\r\n      // console.log('Copied Text:', window.getSelection().toString());\r\n      // console.log('Copied Text:', e.target.parentElement.id);\r\n      const targetElementName=e.target.closest('.dialogue')||e.target.name||e.target.nodeName;\r\n      console.log('Copy Target:', targetElementName);\r\n      sendBehavior({\r\n        id: Date.now(),\r\n        content: window.getSelection().toString(),\r\n        type: 'Copy',\r\n        target_object: targetElementName,\r\n        log_time: new Date().toISOString(),\r\n      })\r\n      highlightedText.value='Copied Text:'+window.getSelection().toString()+ ' from '+ targetElementName\r\n    };\r\n\r\n    const handlePaste = async (e) => {\r\n      const pastedText = await e.clipboardData.getData('text');\r\n      // console.log('Pasted Text:', pastedText);\r\n      const  targetElementName=e.target.closest('.dialogue')||e.target.name||e.target.nodeName;\r\n      sendBehavior({\r\n        id: Date.now(),\r\n        content: pastedText,\r\n        type: 'Paste',\r\n        target_object: targetElementName,\r\n        log_time: new Date().toISOString(),\r\n      })\r\n      highlightedText.value='Copied Text:'+ pastedText + ' from '+ targetElementName\r\n    };\r\n\r\n    // Highlight all text\r\n    const handleHighlight = (e) => {\r\n      \r\n      if ((e.ctrlKey || e.metaKey) && e.key === 'a') {\r\n        // Trigger your highlight logic here\r\n        console.log('Ctrl+A or Command+A pressed');\r\n        // Your existing logic for selecting text...\r\n        let selectedText = '';\r\n        if (textareaRef.value && textareaRef.value.$refs.textarea) {;\r\n          const textarea = textareaRef.value.$refs.textarea;\r\n          selectedText = textarea.value;\r\n        }\r\n        //  console.log('select:', selectedText);\r\n        if (selectedText) {\r\n          const targetElementName=e.target.closest('.dialogue')||e.target.name||e.target.nodeName;\r\n          console.log('targetElementName:', targetElementName);\r\n          sendBehavior({\r\n            id: Date.now(),\r\n            content: selectedText,\r\n            type: 'HighlightAll',\r\n            target_object: targetElementName,\r\n            log_time: new Date().toISOString(),\r\n          })\r\n          highlightedText.value = 'Selected Text: ' + selectedText + ' from '+ targetElementName;\r\n        } \r\n      }\r\n    };\r\n    // Highlight text\r\n    const handleMouseUp = (e) => {\r\n      // console.log('Mouse Up');\r\n\r\n      let selectedText = '';\r\n      // Check if the event's target is the textarea\r\n      if (e.target === textareaRef.value.$refs.textarea) {\r\n        const start = e.target.selectionStart;\r\n        const end = e.target.selectionEnd;\r\n        selectedText = e.target.value.substring(start, end);\r\n      } else {\r\n        // For other elements, continue using window.getSelection\r\n        selectedText = window.getSelection().toString();\r\n      }\r\n      if (selectedText !== '') {\r\n        // Do something with the selected text\r\n        // console.log('Highlight Text:', selectedText);\r\n        const targetElementName=e.target.closest('.dialogue')||e.target.name||e.target.nodeName;\r\n        console.log('targetElementName:', targetElementName);\r\n        // targetElementName.split('_');\r\n        sendBehavior({\r\n          id: Date.now(),\r\n          content: selectedText,\r\n          type: 'Highlight',\r\n          target_object: targetElementName,\r\n          log_time: new Date().toISOString(),\r\n        })\r\n        highlightedText.value='Highlight Text:'+ selectedText+ ' from '+ targetElementName;\r\n      }\r\n      // Update the session storage\r\n      // console.log('textArea Text:', textArea.value);\r\n      // localStorage.setItem('storage_notes', textArea.value);\r\n\r\n    };\r\n\r\n    const startFocusTime = () => {\r\n      if (focusTimeStart === 0) {\r\n        focusTimeStart = new Date().getTime();\r\n      }\r\n    };\r\n\r\n    const endFocusTime = (e) => {\r\n      focusTimeEnd = new Date().getTime();\r\n      // console.log('Time Spent:', (focusTimeEnd - focusTimeStart) / 1000);\r\n      highlightedText.value='Focus Time Spent:'+ (focusTimeEnd - focusTimeStart) / 1000\r\n      const targetElementName = e.target.name||e.target.id||e.target.nodeName;\r\n      sendBehavior({\r\n        id: Date.now(),\r\n        content: (focusTimeEnd - focusTimeStart) / 1000,\r\n        type: 'FOCUS_TIME',\r\n        target_object: targetElementName,\r\n        log_time: new Date(focusTimeEnd).toISOString(),\r\n      })\r\n      focusTimeStart = 0;\r\n    };\r\n\r\n    const handleVisibilityChange= () => {\r\n      console.log('Visibility Change:', document.visibilityState);\r\n\r\n      if (document.visibilityState === 'visible') {\r\n        // console.log('User is focused on the page');\r\n        sendBehavior({\r\n            id: Date.now(),\r\n            content: (new Date().getTime()-focus_leave)/1000,\r\n            type: 'Leaving Time',\r\n            target_object: 'Page',\r\n            log_time: new Date().toISOString(),\r\n        })  \r\n        highlightedText.value='User is focused on the page'\r\n      } else {\r\n        sendBehavior({\r\n            id: Date.now(),\r\n            content: (new Date().getTime()-focus_leave)/1000,\r\n            type: 'Stay Time',\r\n            target_object: 'Page',\r\n            log_time: new Date().toISOString(),\r\n        })  \r\n        // console.log('User has left the page');\r\n        // Perform actions when the page is not in focus\r\n      }\r\n      focus_leave=new Date().getTime();\r\n    };\r\n    \r\n    window.addEventListener('resize', () => {\r\n      if(window.innerWidth<992){\r\n        // console.log(\"Window width:\", window.innerWidth); \r\n        // console.log('Mobile View');\r\n        mobileDrawer.value = true;\r\n      }\r\n      else{\r\n        mobileDrawer.value = false;\r\n      }\r\n      if(window.innerHeight<768){\r\n        textAreaRowRef.value = 6;\r\n      }\r\n      else if(window.innerHeight<992){\r\n        textAreaRowRef.value = 8;\r\n      }\r\n      else if (window.innerHeight<1024){\r\n        textAreaRowRef.value = 10;\r\n      }\r\n      else{\r\n        textAreaRowRef.value = 12;\r\n      }\r\n    })\r\n\r\n    // const onSubmitTask = async () => {\r\n    //   console.log('Task Submitted:', textArea.value);\r\n    //   sendBehavior({\r\n    //     id: Date.now(),\r\n    //     content: textArea.value,\r\n    //     type: 'Task Submission',\r\n    //     target_object: 'textarea',\r\n    //     log_time: new Date().toISOString(),\r\n    //   })\r\n    //   highlightedText.value='Task Submitted:'+ textArea.value\r\n    // };\r\n\r\n\r\n    // unused function\r\n    // The UI conditions parts\r\n    const isLastChatbotMessage = (message) => {\r\n      const lastIndex = messages.value.length - 1;\r\n      const lastMessage = messages.value[lastIndex];\r\n      return message.id === lastMessage.id && lastMessage.sender === 'assistant';\r\n    };\r\n\r\n    // unused function\r\n    // Resent the chatbot message\r\n    const resentMessage = (up) => {\r\n      const RESENT_PROMPT=\"Give me another idea?\"\r\n      if(up){\r\n        currentTemp.value+=0.1;\r\n      }\r\n      else{\r\n        currentTemp.value-=0.1;\r\n      }\r\n      createMessage((0,marked__WEBPACK_IMPORTED_MODULE_2__.marked)(RESENT_PROMPT),'user')\r\n      getResponse(RESENT_PROMPT)\r\n    };\r\n\r\n\r\n    // Listen the ipAddress\r\n    const getIPFromAmazon=async()=> {\r\n      await fetch(\"https://checkip.amazonaws.com/\").then(res => res.text()).then(data => {\r\n        ipAddress.value = data;\r\n        })\r\n    }\r\n\r\n    return { messages,\r\n      attendTour,\r\n      timeSeconds,\r\n      messageSending,\r\n      minWords,\r\n      maxWords, \r\n      userInput, \r\n      scenarioRef,\r\n      noteRef,\r\n      chatBotRef,\r\n      submitTaskRef,\r\n      chatInputRef,\r\n      infoRef,\r\n      open,\r\n      tourFinished,\r\n      scenarioText,\r\n      textArea,\r\n      textAreaWordCount,\r\n      checkTaskFinish,\r\n      onSubmitTask,\r\n      handleInput,\r\n      handlePromptInput,\r\n      handleCopiedButton, \r\n      clearTextArea,\r\n      textareaRef,\r\n      sendMessage,\r\n      highlightedText,\r\n      handleHighlight,\r\n      handleCopy,\r\n      handlePaste,\r\n      handleMouseUp,\r\n      startFocusTime,\r\n      hasFinishTask,\r\n      endFocusTime,\r\n      drawer,\r\n      mobileDrawer,\r\n      scrollToBottom,\r\n      scrollContainer,\r\n      isLastChatbotMessage,\r\n      MAX_TEMP,\r\n      MIN_TEMP,\r\n      currentTemp,\r\n      resentMessage,\r\n      textAreaRowRef,\r\n    };\r\n  },\r\n});\r\n\n\n//# sourceURL=webpack://ruby-openai/./frontend_app/pages/Dashboard.vue?./node_modules/unplugin/dist/webpack/loaders/transform.js?unpluginName=unplugin-vue-components!./node_modules/unplugin/dist/webpack/loaders/transform.js?unpluginName=unplugin-auto-import!./node_modules/vue-loader/dist/index.js??ruleSet%5B1%5D.rules%5B6%5D.use%5B0%5D\n}");

/***/ }

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ /* webpack/runtime/getFullHash */
/******/ (() => {
/******/ 	__webpack_require__.h = () => ("8cc5f479ed8b3979e399")
/******/ })();
/******/ 
/******/ }
);